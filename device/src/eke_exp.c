#include <stdio.h>
#include <stdint.h>
#include <string.h>
// For trace_printf
#include "diag/Trace.h"
// My libraries
#include <eke_exp.h>
#include <numth_arith.h>
#include <rng_custom.h>
#include <aes256.h>
#include <hmac_sha256.h>
#include <kms.h>

/**
 * ENCRYPTED EXPONENTIAL KEY EXCHANGE KAP LIBRARY
 * ----------------------------------------------
 * This library implements the main functions needed for a Key Agreement Protocol
 * (KAP) built upon a passsword-base Encrypted Key Exchange (EKE) with exponential
 * key exchange. The protocol is implemented on 32 bit data, and its implementation
 * is based on the literature in:
 * Bellovin, Steven Michael, and Michael Merritt. "Encrypted key exchange:
 * Password-based protocols secure against dictionary attacks." (1992).
 *
 * This library contains the functions to implement the following KAP between two
 * devices A and B:
 * - [A] publishes alpha and beta unencrypted, generates a random RA and sends to [B]
 *   Enc_P(alpha^RA % beta), where P is the hardwired AES-256 key
 * - [B] decrypts alpha^RA % beta, generates a random RB, computes alpha^RA*RB % beta
 *   and uses it as a seed for HMAC-SHA256 to generate the key K; then sends to [A]
 *   Enc_P(alpha^RB % beta) and Enc_P(challengeB)
 * - [A] computes alpha^RA*RB % beta and generates the same key K, then decrypts the
 *   challengeB, computes its reply and sends to [B] Enc_P(challengeA) and
 *   Enc_P(solution of challengeB)
 * - [B] verifies the solution to challengeB and sends to [A] Enc_P(solution of
 *   challengeA) and an acknowledgment
 * - [A] verifies the solution to challengeA and sens to [B] and acknowledgment,
 *   definitely storing K in the KMS
 * - [B] if it receives the acknowledgment, it stores K in the KMS
 */


/************************************* DEFINES *************************************/

#define __VERBOSE  /* Enable verbose trace_printf EKE KAP interface messages */

/************************************ VARIABLES ************************************/

/**
 * There are some variables values which are to be retained among different steps of
 * the protocol, i.e. among different function calls; such parameters are implemented
 * as global variables reset at the beginning and at the end of the KAP procedure and
 *  updated when needed.
 */

uint32_t beta; /* Used as modulus; it comes from 2*p+1, with p being a big prime */

uint32_t local_rnd; /* Contains the locally-generated random number used as exponent */
uint32_t local_challenge; /* Contains the random challenge */

uint16_t shared_key_size; /* Size of the key which must be agreed upon */
uint8_t shared_key[HASH_OUTPUT_LEN]; /* Key on which both devices agree, generated by hashing shared_pow */


/****************************** FUNCTIONS DEFINITIONS ******************************/

/* ------------------------------------------------------------------------------- */
/* ---------------------------- Protocol functions ------------------------------- */
/* ------------------------------------------------------------------------------- */

/**
 * Function eke_init
 * -----------------
 * Initialize the protocol
 */
void eke_init(){
	eke_kap_reset();
}

/**
 * Function eke_kap_step1_a
 * ------------------------
 * Device A generates beta and alpha parameters used for exponentiation: beta is a
 * large prime number with certain characteristics, while alpha is a primitive root
 * of beta. A local random number local_rnd is then generated to compute the result
 * of the local exponentiation alpha^local_rnd mod beta.
 * Beta and alpha unencrypted are then sent to B in plain text, while the result of
 * the local exponentiation is encrypted with AES-256, using a password hardcoded in
 * the device as key equal for all device, and sent as well.
 * Beta and alpha are returned to the caller through ret_beta and ret_alpha pointers,
 * while the encrypted (alpha^local_rnd mod beta) is written to the array of uint8_t
 * pointed by enc_pow_a (the caller must allocate an array of 16 uint8_t, i.e. the
 * minimum size of AES-256 output, padding the 4-byte input until 16 bytes).
 * The function returns: >0 -> if successful; this return value should always be AES_BLOCK_SIZE
 *                             and represents the size in bytes of the encrypted local_pow
 *                        0 -> primitive root of beta not found while generating alpha
 *                       -1 -> hard fault (on RNG or not enough space for factors)
 */
int eke_kap_step1_a(uint32_t *ret_beta, uint32_t *ret_alpha, uint8_t *enc_pow_a){
	uint32_t alpha; // Used in exponentiation; it is a primitive root of GF(beta)
	uint32_t local_pow; // Contains the results of the local exponentiations

	int ret;
	int enc_len;

	eke_kap_reset(); // reser KAP state

	// Generate beta and alpha parameters
	ret = generate_beta_alpha(&beta, &alpha);
	if (ret == 0){
		// return warning
		#ifdef __VERBOSE
		trace_printf("WARNING: (eke_exp - 1.1) Error @ generate_beta_alpha in eke_kap_step1_a: primitive root of beta not found.\n");
		#endif
		return 0;
	}else if (ret < 0){
		// return error and abort
		#ifdef __VERBOSE
		trace_printf("ERROR: (eke_exp - 1.2) Error @ generate_beta_alpha in eke_kap_step1_a.\n");
		#endif
		return -1;
	}
	// Return beta and alpha to caller
	*ret_beta = beta;
	*ret_alpha = alpha;

	// Generate local random number R_a
	ret = rng_get_random32(&local_rnd);
	if(ret){
		// return error and abort
		#ifdef __VERBOSE
		trace_printf("ERROR: (eke_exp - 1.3) Error @ rng_get_random32 in eke_kap_step1_a.\n");
		#endif
		return -1;
	}
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 1.4) Locally generated random number is: %u.\n", local_rnd);
	#endif
	// Compute local exponentiation: alpha^local_rnd mod beta
	local_pow = pow_mod(alpha, local_rnd, beta);
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 1.5) Result of local exponentiation is: %u.\n", local_pow);
	#endif

	// Encrypt (alpha^local_rnd mod beta) and return it
	// enc_len should always be AES_BLOCK_SIZE, because sizeof(uint32_t) = 4, which is < AES_BLOCK_SIZE = 16
	enc_len = encrypt_cbc((char*)(&local_pow), sizeof(uint32_t), (char*)EKE_AES_KEY, (char*)enc_pow_a);

	return enc_len; // return output length in bytes
}

/**
 * Function eke_kap_step2_b
 * ------------------------
 * Device B receives the parameter beta and alpha and decrypts the result of the
 * remote exponentiation computed by A. Also, it generates its local exponentiation
 * with alpha, local_rnd and beta and encrypts it with the common password. Device B
 * also generates the result of the shared exponentiation remote_pow^local_rnd mod
 * beta, which is hashed with HMAC-SHA256 and an hardcoded key to create the shared
 * key on which the two devices want to agree. Finally, a random challenge consisting
 * of a random 32-bit number is generated.
 * Device B sends back to A the result of its local exponentiation encrypted with the
 * common password and the ranom challenge encrypted with the new sharedk key.
 * It returns: >0 -> if successful; should always be AES_BLOCK_SIZE*2 and represents
 *                   the size in bytes of the encrypted local_pow and local_challenge
 *             -2 -> too big key size, impossible to generate from HMAC-SHA256 hash
 *             -1 -> hard fault on RNG
 */
int eke_kap_step2_b(uint32_t beta, uint32_t alpha, uint8_t *enc_pow_a, uint8_t *enc_pow_b, uint8_t *enc_chlg_b, uint16_t key_size){
	uint32_t local_pow; // Contains the results of the local exponentiations

	uint8_t dec_pow_a[AES_BLOCK_SIZE];
	uint32_t remote_pow; // Results of the decryption of remote exponentiation
	uint32_t shared_pow; // Result of the two exponentiations, on which both devices agree

	uint8_t hash[HASH_OUTPUT_LEN];

	int ret;
	int enc_len = 0;

	eke_kap_reset(); // reser KAP state

	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 2.1) Beta = %u and alpha = %u parameters received.\n", beta, alpha);
	#endif

	// Check if desired key size can be generated from HMAC-SHA256 output
	if (key_size > HASH_OUTPUT_LEN){
		// return too big key size error
		#ifdef __VERBOSE
		trace_printf("WARNING: (eke_exp - 2.2) Error @ key_size > %u in eke_kap_step2_b.\n", HASH_OUTPUT_LEN);
		#endif
		return -2;
	}
	// save in global variable
	shared_key_size = key_size;

	// Decrypt remote_pow (result of remote exponentiation)
	decrypt_cbc((char*)enc_pow_a, AES_BLOCK_SIZE, (char*)EKE_AES_KEY, (char*)dec_pow_a);
	remote_pow = *((uint32_t*)(dec_pow_a));
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 2.3) Decryption of remote exponentiation resulted in: %u.\n", remote_pow);
	#endif

	// Generate local random number R_b
	ret = rng_get_random32(&local_rnd);
	if(ret){
		// return error and abort
		#ifdef __VERBOSE
		trace_printf("ERROR: (eke_exp - 2.4) Error @ generate_beta_alpha in eke_kap_step2_b.\n");
		#endif
		return -1;
	}
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 2.5) Locally generated random number is: %u.\n", local_rnd);
	#endif

	// Compute local_pow (result of local exponentiation)
	local_pow = pow_mod(alpha, local_rnd, beta);
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 2.6) Result of local exponentiation is: %u.\n", local_pow);
	#endif
	// Encrypt and return local exponentiation in enc_pow_b
	enc_len += encrypt_cbc((char*)(&local_pow), sizeof(uint32_t), (char*)EKE_AES_KEY, (char*)enc_pow_b);

	// Compute shared_pow (result of shared exponentiation): alpha^(local_rnd * remote_rnd) mod beta
	// computed as remote_pow^local_rnd mod beta
	shared_pow = pow_mod(remote_pow, local_rnd, beta);
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 2.7) Result of shared exponentiation is: %u.\n", shared_pow);
	#endif

	// Compute shared key by hashing shared_pow (output of hmac-sha256 is always 32 bytes)
	hmac_sha256((uint8_t*)(&shared_pow), sizeof(uint32_t), (uint8_t*)EKE_HMAC_KEY, EKE_HMAC_KEY_LEN, hash);
	// Cast desired number of bytes to shared key
	memcpy((void*)shared_key, (void*)hash, key_size);

	// Generate local challenge
	ret = rng_get_random32(&local_challenge);
	if(ret){
		// return error and abort
		#ifdef __VERBOSE
		trace_printf("ERROR: (eke_exp - 2.8) Error @ rng_get_random32 in eke_kap_step2_b.\n");
		#endif
		return -1;
	}
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 2.9) Locally generated random challenge is: %u.\n", local_challenge);
	#endif
	// Encrypt and return local challenge in enc_chlg_b
	enc_len += encrypt_cbc((char*)(&local_challenge), sizeof(uint32_t), (char*)shared_key, (char*)enc_chlg_b);

	return enc_len; // return output length in bytes
}

/**
 * Function eke_kap_step3_a
 * ------------------------
 * Device A receives the result of B local exponentiation and decrypts it. As in B, A
 * now can generate the result of the shared exponentiation, and derive the new
 * shared key by hashing it.
 * With the new shared key device A can decrypt the random challenge and solve it
 * (i.e. apply the operations defined by the function solve_challenge); then it
 * creates a new random challenge for B. The reply to the challenge from B and the
 * new random challenge generated by A are concatenated and encrypted with the new
 * shared password, then sent to device B.
 * The array pointed by enc_reply is filled with two uint32 (4 bytes each) encrypted
 * with AES-256 (thus 16 bytes in total), namely the reply to the challenge remotely
 * generated by device B and the random challenge generated locally by device A.
 * It returns: >0 -> if successful; should always be AES_BLOCK_SIZE and is the size
 *                   in bytes of the encrypted local_challenge and challenge_reply_a
 *             -2 -> too big key size, impossible to generate from HMAC-SHA256 hash
 *             -1 -> hard fault
 */
int eke_kap_step3_a(uint8_t *enc_pow_b, uint8_t *enc_chlg_b, uint8_t *enc_reply_a, uint16_t key_size){
	uint8_t dec_pow_b[AES_BLOCK_SIZE];
	uint32_t remote_pow; // Results of the decryption of remote exponentiation
	uint8_t dec_chlg_b[AES_BLOCK_SIZE];
	uint32_t remote_challenge; // Random challenge generated by device B

	uint32_t challenge_reply_a; // Reply to the random challenge generated by B, computed locally

	uint32_t shared_pow; // Result of the two exponentiations, on which both devices agree
	uint8_t hash[HASH_OUTPUT_LEN];

	int ret;
	int enc_len;
	uint8_t reply[sizeof(uint32_t)*2]; // Encrypt_K(reply to chlg from B, new rand chlf from A)

	// Check if desired key size can be generated from HMAC-SHA256 output
	if (key_size > HASH_OUTPUT_LEN){
		// return too big key size error
		#ifdef __VERBOSE
		trace_printf("ERROR: (eke_exp - 3.1) Error @ key_size > %u in eke_kap_step3_a.\n", HASH_OUTPUT_LEN);
		#endif
		return -2;
	}
	// save in global variable
	shared_key_size = key_size;

	// Decrypt remote_pow (result of remote exponentiation)
	decrypt_cbc((char*)enc_pow_b, AES_BLOCK_SIZE, (char*)EKE_AES_KEY, (char*)dec_pow_b);
	remote_pow = *((uint32_t*)(dec_pow_b));
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 3.2) Decryption of remote exponentiation resulted in: %u.\n", remote_pow);
	#endif
	// Compute shared_pow (result of shared exponentiation): alpha^(local_rnd * remote_rnd) mod beta
	// computed as remote_pow^local_rnd mod beta
	shared_pow = pow_mod(remote_pow, local_rnd, beta);
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 3.3) Result of shared exponentiation is: %u.\n", shared_pow);
	#endif

	// Compute shared key by hashing shared_pow (output of hmac-sha256 is always 32 bytes)
	hmac_sha256((uint8_t*)(&shared_pow), sizeof(uint32_t), (uint8_t*)EKE_HMAC_KEY, EKE_HMAC_KEY_LEN, hash);
	// Cast desired number of bytes to shared key
	memcpy((void*)shared_key, (void*)hash, key_size);

	// Generate local challenge
	ret = rng_get_random32(&local_challenge);
	if(ret){
		// return error and abort
		#ifdef __VERBOSE
		trace_printf("ERROR: (eke_exp - 3.4) Error @ rng_get_random32 in eke_kap_step3_a.\n");
		#endif
		return -1;
	}
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 3.5) Locally generated random challenge is: %u.\n", local_challenge);
	#endif

	// Decrypt challenge from device B
	decrypt_cbc((char*)enc_chlg_b, AES_BLOCK_SIZE, (char*)shared_key, (char*)dec_chlg_b);
	remote_challenge = *((uint32_t*)(dec_chlg_b));
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 3.6) Decryption of remotely generated challenge resulted in: %u.\n", remote_challenge);
	#endif
	// Compute challenge reply
	challenge_reply_a = solve_challenge(remote_challenge);

	// Pack random challenge from A and reply to challenge from B
	memcpy((void*)reply, (void*)(&challenge_reply_a), sizeof(uint32_t));
	memcpy((void*)(reply + sizeof(uint32_t)), (void*)(&local_challenge), sizeof(uint32_t));
	// Encrypt reply
	enc_len = encrypt_cbc((char*)reply, sizeof(uint32_t)*2, (char*)shared_key, (char*)enc_reply_a);

	return enc_len; // return output size
}

/**
 * Function eke_kap_step4_b
 * ------------------------
 * Device B decrypts the reply from A, and extracts the response to its challenge and
 * the new challenge from A. Then it verifies that the solution of device A to the
 * challenge B is correct, then computes the reply to the challenge from A, encrypts
 * it and sends it back to A.
 * The array pointed by enc_reply is filled with one uint32 (4 bytes) encrypted with
 * AES-256 (thus 16 bytes in total), which is the reply to the challenge remotely
 * generated by device A.
 * It returns: >0 -> if successful; should always be AES_BLOCK_SIZE and is the size
 *                   in bytes of the encrypted challenge_reply_b
 *             -2 -> the challenge solution received from A is not correct
 *             -1 -> hard fault
 */
int eke_kap_step4_b(uint8_t *enc_reply_a, uint8_t *enc_reply_b){
	uint8_t dec_reply_a[AES_BLOCK_SIZE];
	uint32_t challenge_reply_a; // Reply to the random challenge generated by B, computed remotely by A
	uint32_t remote_challenge; // Random challenge generated by device A

	uint32_t challenge_reply_b; // Reply to the random challenge generated by A, computed locally

	int enc_len;

	// Decrypt reply and decode it
	decrypt_cbc((char*)enc_reply_a, AES_BLOCK_SIZE, (char*)shared_key, (char*)dec_reply_a);
	challenge_reply_a = *((uint32_t*)(dec_reply_a));  // decode reply of A to challenge from B
	remote_challenge = *((uint32_t*)dec_reply_a + 1); // decode A's remote challenge
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 4.1) Decryption of received challenge solution resulted in: %u.\n", challenge_reply_a);
	trace_printf("MESSAGE: (eke_exp - 4.2) Decryption of remotely generated challenge resulted in: %u.\n", remote_challenge);
	#endif

	// Verify solution of the challenge
	if (challenge_reply_a != solve_challenge(local_challenge)){
		// wrong challenge solution received from A
		#ifdef __VERBOSE
		trace_printf("WARNING: (eke_exp - 4.3) Error @ challenge_reply_a != solve_challenge(local_challenge) in eke_kap_step4_b.\n");
		#endif
		return -2;
	}

	// Compute reply to challenge generated by A
	challenge_reply_b = solve_challenge(remote_challenge);

	// Encrypt reply
	enc_len = encrypt_cbc((char*)(&challenge_reply_b), sizeof(uint32_t), (char*)shared_key, (char*)enc_reply_b);

	return enc_len; // return output size
}

/**
 * Function eke_kap_step5_a
 * ------------------------
 * Device A receives reply from B, containing the response to the challenge that A
 * generated for B to solve, and decrypts it with the new shared password. If the
 * solution is correct, it stores the newly generated shared key in the KMS database,
 * and returns a positive acknowledgment as return value, to tell B to do the same.
 * This function returns a value used as acknowledgment for the communication between
 * the host and device B: if it returns 0, the host communicates a positive ACK to
 * device B, which also stores the shared key, otherwise a negative outcome is sent.
 * It returns:  0 -> if successful; the challenge solution is correct
 *             -2 -> WARNING: the challenge solution received from B is not correct
 *             -3 -> WARNING: no space left in KMS storage to add a new key
 *             -4 -> WARNING: key with given key_id already present in KMS database
 *             -1 -> ERROR: an hard fault occurred in KMS
 */
int eke_kap_step5_a(uint8_t *enc_reply_b, uint32_t key_id, uint32_t key_cryptoperiod){
	uint8_t dec_reply_b[AES_BLOCK_SIZE];
	uint32_t challenge_reply_b; // Reply to the random challenge generated by B, computed remotely by A

	int ret;

	// Decrypt reply and decode it
	decrypt_cbc((char*)enc_reply_b, AES_BLOCK_SIZE, (char*)shared_key, (char*)dec_reply_b);
	challenge_reply_b = *((uint32_t*)(dec_reply_b)); // decode reply of B to challenge from A
	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 5.1) Decryption of received challenge solution resulted in: %u.\n", challenge_reply_b);
	#endif

	// Verify solution of the challenge
	if (challenge_reply_b != solve_challenge(local_challenge)){
		// wrong challenge solution received from B
		#ifdef __VERBOSE
		trace_printf("WARNING: (eke_exp - 5.2) Error @ challenge_reply_b != solve_challenge(local_challenge) in eke_kap_step5_a.\n");
		#endif
		return -2; // return -2 as negative ACK
	}
	// Solution is correct, store agreed key in KMS and return 0 as positive ACK
	ret = kms_add_plain_key(key_id, shared_key_size, shared_key, key_cryptoperiod);
	if (ret == 1){
		// success
		eke_kap_reset();
		return 0;
	} else if(ret == 0){
		// WARNING: no space left to add a new key
		#ifdef __VERBOSE
		trace_printf("WARNING: (eke_exp - 5.3) Error @ kms_add_plain_key in eke_kap_step5_a.\n");
		#endif
		return -3;
	} else if (ret == -2) {
		// WARNING: key with given key_id already present in KMS database
		#ifdef __VERBOSE
		trace_printf("WARNING: (eke_exp - 5.4) Error @ kms_add_plain_key in eke_kap_step5_a.\n");
		#endif
		return -4;
	} else {
		// ERROR: an hard fault occurred
		#ifdef __VERBOSE
		trace_printf("ERROR: (eke_exp - 5.5) Error @ kms_add_plain_key in eke_kap_step5_a.\n");
		#endif
		return -1;
	}
}

/**
 * Function eke_kap_step6_b
 * ------------------------
 * The action of the host of launching this function is equivalent to sending a
 * positive ACK to device B, which thus stores the agreed key in its KMS too.
 * This function should be launched only if the step #5 in device A returned with a
 * positive outcome.
 * It returns:  0 -> if key stored successfully
 *             -2 -> WARNING: no space left in KMS storage to add a new key
 *             -3 -> WARNING: key with given key_id already present in KMS database
 *             -1 -> ERROR: an hard fault occurred in KMS
 */
int eke_kap_step6_b(uint32_t key_id, uint32_t key_cryptoperiod){
	int ret;

	// store agreed key in KMS
	ret = kms_add_plain_key(key_id, shared_key_size, shared_key, key_cryptoperiod);
	if (ret == 1){
		// success
		eke_kap_reset();
		return 0;
	} else if(ret == 0){
		// WARNING: no space left to add a new key
		#ifdef __VERBOSE
		trace_printf("WARNING: (eke_exp - 6.1) Error @ kms_add_plain_key in eke_kap_step6_b.\n");
		#endif
		return -2;
	} else if (ret == -2) {
		// WARNING: key with given key_id already present in KMS database
		#ifdef __VERBOSE
		trace_printf("WARNING: (eke_exp - 6.2) Error @ kms_add_plain_key in eke_kap_step6_b.\n");
		#endif
		return -3;
	} else {
		// ERROR: an hard fault occurred
		#ifdef __VERBOSE
		trace_printf("ERROR: (eke_exp - 6.3) Error @ kms_add_plain_key in eke_kap_step6_b.\n");
		#endif
		return -1;
	}
}

/**
 * Function eke_kap_reset
 * ----------------------
 * Reset to zero all global variables used as buffers by the protocol; useful to
 * avoid information leak due to stale data still present in the device.
 */
void eke_kap_reset(){
	beta = 0;
	local_rnd = 0;
	local_challenge = 0;
	shared_key_size = 0;
	for(int i = 0; i < HASH_OUTPUT_LEN; i++){
		shared_key[i] = 0;
	}
}


/* ------------------------------------------------------------------------------- */
/* -------------------------------- Utilities ------------------------------------ */
/* ------------------------------------------------------------------------------- */

/**
 * Function generate_beta_alpha
 * ----------------------------
 * Compute parameters beta, used as modulus for exponentiation in the KAP, and alpha,
 * used as base for the exponentiation.
 * Beta is computed by generating a big random 32-bit number and checking that:
 * - it is a prime number (with a fast primality test)
 * - it is large enough (>= 2^26), not to be susceptible to precalculation of tables
 * - beta-1 (= phi(beta) since beta is prime) has at least one large factor, to guard
 *   against Pohlig and Hellman's algorithm
 * as in "Encrypted key exchange: Password-based protocols secure against dictionary
 * attacks." (1992).
 * Alpha is instead computed as a primitive root of the field GF(beta), by computing
 * the factors of the Euler's totient of beta (= phi(beta) = beta-1 due to beta being
 * prime).
 *
 * The function returns: 1 -> if beta and alpha have been generated successfully
 *                       0 -> if beta has been generated but no primitive roots found
 *                      -1 -> hard fault (RNG or too many factors for memory)
 */
int generate_beta_alpha(uint32_t *beta, uint32_t *alpha){

	/* Beta generation */
	uint32_t rnd;
	int ret;

	uint32_t factors[50]; // array to contain factors from random prime factorization
	int fact_num; // number of elements contained in factors array
	uint8_t found = 0; // large enough factor of random prime found

	/**
	 * There are 199.322.412 prime numbers between 2^26 and 2^32-1, i.e. there is
	 * approximately a 4.7% chance of obtaining a prime number from a random 32 bits
	 * number larger than 2^26 number, meaning that the primality test in the loop
	 * will be repeated on average 21.2 times to find a random prime number.
	 * Additionally to this, the primality test may be repeated several further times
	 * to find a large enough prime number such that rnd-1 also has a large enough
	 * prime factor
	 */
	while(1){
		// Generate a big random 32-bit number
		ret = rng_get_random32(&rnd);
		if(ret){
			// return error and abort
			#ifdef __VERBOSE
			trace_printf("ERROR: (eke_exp - 7.1) Error @ rng_get_random32 in generate_beta_alpha.\n");
			#endif
			return -1;
		}
		rnd = rnd + 0x04000000; // scale rnd between 2^26 and 2^32-1 (exploit saturation on 32 bits)
		// If rnd is a prime number, factorize rnd-1 and check if it has a large prime factor
		if(is_prime(rnd)){
			fact_num = factorize(rnd-1, factors, 50);
			if(fact_num < 0){
				// return error and abort if amount of factors does not fit in allocated memory
				#ifdef __VERBOSE
				trace_printf("ERROR: (eke_exp - 7.2) Error @ factorize in generate_beta_alpha.\n");
				#endif
				return -1;
			}
			for(int i = 0; i < fact_num; i++)
				if (factors[i] >= 0x02000000){ // large enough factor considered >= 2^25
					found = 1;
					break;
				}
			if(found){
				#ifdef __VERBOSE
				trace_printf("MESSAGE: (eke_exp - 7.3) Large random prime p such that p-1 has a large prime factor found: %u.\n", rnd);
				#endif
				break;
			}
		}
	}
	// Assign beta
	*beta = rnd;

	/* Alpha generation */
	uint32_t prim_root;

	ret = primitive_root(*beta, &prim_root);
	if (ret == 0) {
		// no primitive roots of beta found
		#ifdef __VERBOSE
		trace_printf("WARNING: (eke_exp - 7.4) Error @ primitive_root in generate_beta_alpha.\n", rnd);
		#endif
		return 0;
	}
	else if (ret < 0){
		// return error and abort
		#ifdef __VERBOSE
		trace_printf("ERROR: (eke_exp - 7.5) Error @ primitive_root in generate_beta_alpha.\n");
		#endif
		return -1;
	}

	*alpha = prim_root;

	#ifdef __VERBOSE
	trace_printf("MESSAGE: (eke_exp - 7.6) Beta = %u and alpha = %u successfully generated.\n", *beta, *alpha);
	#endif
	return 1;
}

/**
 * Function solve_challenge
 * ------------------------
 * Some deterministic function applied to uint32_t challenge input. The function
 * returns the solution to the challenge as an uint32_t.
 */
uint32_t solve_challenge(uint32_t challenge){
	return (challenge ^ 0x62F870A0) + 0x00A02ADE;
}
